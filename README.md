# 基于DPLL算法解决3-SAT问题

### 问题描述 
给定m个涉及到n个boolean变量的表达式，找出如何对这几个变量赋值，让这m个boolean表达式同时为true。这种问题的答案不一定唯一
例子:给定下列4个boolean表达式，如何去变量的值同时使这些表达式的答案为 true:

$X_1 \cup \overline{X_2} \cup \overline{X_4}$， $X_2 \cup \overline{X_3} \cup X_4$，
$X_2 \cup X_3 \cup X_4$， $X_2 \cup X_3 \cup \overline{X_4}$

答案一: $$X_1$$, $$X_2$$ 为true, $$X_3$$, $$X_4$$ 自由选取。
答案二: $$X_1$$, $$X_3$$ 任意, $$X_2$$ 为true, $$X_4$$ 为false。

输入格式：  
(1)头一个整数为变量数n。   
(2)接下来的整数为表达式个数m。   
(3)然后就是m组整数，每组为三个整数，每个整数代表相关变量和是否为其非值;数值大小表示变量，正负表达是否非值。   
上述例子的输入如下:   
4    
4    
1 -2 -4   
2 -3  4   
2  3  4   
2  3 -4   

### DPLL算法
DPLL算法，全称为Davis-Putnam-Logemann-Loveland算法，是一种完备的、基于回溯的搜索算法，用于解决命题逻辑中的布尔可满足性问题（SAT）‌。该算法通过尝试不同的变量赋值，并利用逻辑运算的性质来逐步缩小搜索空间，直到找到满足条件的赋值或确定不存在这样的赋值为止。

### 算法流程
(1)输入变量数n，表达式数m以及所有表达式，并将所有变量标记为未赋值状态；
(2)选择变量：从未赋值的变量中选择一个进行赋值，通常选择频率较高的变量。
递归回溯：尝试赋值为真（1）或假（0），并递归调用DPLL函数。如果某个分支导致无解，撤销该赋值，尝试另一个值；
(3)单位传播：在每次递归中检查公式的子句。如果某个子句中只有一个未赋值的变量，该变量必须取值使得该子句为真；
(4)返回结果：如果所有子句都被满足，返回成功；如果无法满足，则返回无解。

### 数据结构  
(1)布尔公式结构：       
`Clause`：用`vector<int>`表示一个子句，其中的整型表示布尔变量及其符号（正数表示真，负数表示假）。      
`Formula`：用`vector<Clause>`表示整个布尔公式，即多个子句的集合。       
(2)变量赋值管理：  
`vector<int> assignment`：用于存储每个变量的赋值状态（-1表示未赋值，0表示假，1表示真）。   
`unordered_set<int> unassigned`：用于跟踪未赋值的变量集合，方便快速选择未赋值变量。   
(3)赋值栈：  
`vector<int> localImplicitAssignments`：记录隐式赋值，用于回溯时撤销。  
`vector<int> localExplicitAssignments`：记录显式赋值，同样用于回溯。  

### 使用方法
#### 解题
testData1/2/3.txt是三个测试数据，保证一定至少存在一个解。   
在main.cpp中修改文件路径为自己的路径后编译运行即可得到输出
#### 验证 
在verify.py中，先输入所有信息(变量数n, 表达式数m, 以及所有表达式)，再输入所有1-0串即可得到结果


