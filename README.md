# 基于DPLL算法解决3-SAT问题

### 问题描述 
给定m个涉及到n个boolean变量的表达式，找出如何对这几个变量赋值，让这m个boolean表达式同时为true。这种问题的答案不一定唯一
例子:给定下列4个boolean表达式，如何去变量的值同时使这些表达式的答案为 true:

$$X_1 \cup \overline{X_2} \cup \overline{X_4}$$ 
$$X_2 \cup \overline{X_3} \cup X_4$$
$$X_2 \cup X_3 \cup X_4$$
$$X_2 \cup X_3 \cup \overline{X_4}$$

答案一: $$X_1$$, $$X_2$$ 为true, $$X_3$$, $$X_4$$ 自由选取。
答案二: $$X_1$$, $$X_3$$ 任意, $$X_2$$ 为true, $$X_4$$ 为false。

### DPLL算法
DPLL算法，全称为Davis-Putnam-Logemann-Loveland算法，是一种完备的、基于回溯的搜索算法，用于解决命题逻辑中的布尔可满足性问题（SAT）‌。该算法通过尝试不同的变量赋值，并利用逻辑运算的性质来逐步缩小搜索空间，直到找到满足条件的赋值或确定不存在这样的赋值为止。

### 算法流程
(1)输入变量数n，表达式数m以及所有表达式，并将所有变量标记为未赋值状态；
(2)选择变量：从未赋值的变量中选择一个进行赋值，通常选择频率较高的变量。
递归回溯：尝试赋值为真（1）或假（0），并递归调用DPLL函数。如果某个分支导致无解，撤销该赋值，尝试另一个值；
(3)单位传播：在每次递归中检查公式的子句。如果某个子句中只有一个未赋值的变量，该变量必须取值使得该子句为真；
(4)返回结果：如果所有子句都被满足，返回成功；如果无法满足，则返回无解。

### 数据结构
(1)布尔公式结构：
`Clause`：用`vector<int>`表示一个子句，其中的整型表示布尔变量及其符号（正数表示真，负数表示假）。
`Formula`：用`vector<Clause>`表示整个布尔公式，即多个子句的集合。
(2)变量赋值管理：
`vector<int> assignment：`用于存储每个变量的赋值状态（-1表示未赋值，0表示假，1表示真）。
`unordered_set<int> unassigned`：用于跟踪未赋值的变量集合，方便快速选择未赋值变量。
(3)赋值栈：
`vector<int> localImplicitAssignments`：记录隐式赋值，用于回溯时撤销。
`vector<int> localExplicitAssignments`：记录显式赋值，同样用于回溯。

